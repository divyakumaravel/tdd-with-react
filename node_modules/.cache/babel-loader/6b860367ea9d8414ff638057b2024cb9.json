{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.propsOfNode = propsOfNode;\nexports.childrenOfNode = childrenOfNode;\nexports.hasClassName = hasClassName;\nexports.treeForEach = treeForEach;\nexports.treeFilter = treeFilter;\nexports.findParentNode = findParentNode;\nexports.pathToNode = pathToNode;\nexports.parentsOfNode = parentsOfNode;\nexports.nodeHasId = nodeHasId;\nexports.nodeMatchesObjectProps = nodeMatchesObjectProps;\nexports.getTextFromNode = getTextFromNode;\nexports.getTextFromHostNodes = getTextFromHostNodes;\nexports.getHTMLFromHostNodes = getHTMLFromHostNodes;\n\nvar _object = require('object.assign');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayPrototype = require('array.prototype.flat');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _object3 = require('object.entries');\n\nvar _object4 = _interopRequireDefault(_object3);\n\nvar _isSubset = require('is-subset');\n\nvar _isSubset2 = _interopRequireDefault(_isSubset);\n\nvar _functionPrototype = require('function.prototype.name');\n\nvar _functionPrototype2 = _interopRequireDefault(_functionPrototype);\n\nvar _isRegex = require('is-regex');\n\nvar _isRegex2 = _interopRequireDefault(_isRegex);\n\nvar _getAdapter = require('./getAdapter');\n\nvar _getAdapter2 = _interopRequireDefault(_getAdapter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction propsOfNode(node) {\n  return node && node.props || {};\n}\n\nfunction childrenOfNode(node) {\n  if (!node) return [];\n  var adapter = (0, _getAdapter2['default'])();\n  var adapterHasIsFragment = adapter.isFragment && typeof adapter.isFragment === 'function';\n  var renderedArray = Array.isArray(node.rendered) ? (0, _arrayPrototype2['default'])(node.rendered, 1) : [node.rendered]; // React adapters before 16 will not have isFragment\n\n  if (!adapterHasIsFragment) {\n    return renderedArray;\n  }\n\n  return (0, _arrayPrototype2['default'])(renderedArray.map(function (currentChild) {\n    // If the node is a Fragment, we want to return its children, not the fragment itself\n    if (adapter.isFragment(currentChild)) {\n      return childrenOfNode(currentChild);\n    }\n\n    return currentChild;\n  }), 1);\n}\n\nfunction hasClassName(node, className) {\n  var classes = propsOfNode(node).className || '';\n  classes = String(classes).replace(/\\s/g, ' ');\n  if ((0, _isRegex2['default'])(className)) return className.test(classes);\n  return (' ' + String(classes) + ' ').indexOf(' ' + String(className) + ' ') > -1;\n}\n\nfunction treeForEach(tree, fn) {\n  if (tree) {\n    fn(tree);\n  }\n\n  childrenOfNode(tree).forEach(function (node) {\n    return treeForEach(node, fn);\n  });\n}\n\nfunction treeFilter(tree, fn) {\n  var results = [];\n  treeForEach(tree, function (node) {\n    if (fn(node)) {\n      results.push(node);\n    }\n  });\n  return results;\n}\n/**\n * To support sibling selectors we need to be able to find\n * the siblings of a node. The easiest way to do that is find\n * the parent of the node and access its children.\n *\n * This would be unneeded if the RST spec included sibling pointers\n * such as node.nextSibling and node.prevSibling\n * @param {*} root\n * @param {*} targetNode\n */\n\n\nfunction findParentNode(root, targetNode) {\n  var results = treeFilter(root, function (node) {\n    if (!node.rendered) {\n      return false;\n    }\n\n    return childrenOfNode(node).indexOf(targetNode) !== -1;\n  });\n  return results[0] || null;\n}\n\nfunction pathFilter(path, fn) {\n  return path.filter(function (tree) {\n    return treeFilter(tree, fn).length !== 0;\n  });\n}\n\nfunction pathToNode(node, root) {\n  var queue = [root];\n  var path = [];\n\n  var hasNode = function hasNode(testNode) {\n    return node === testNode;\n  };\n\n  while (queue.length) {\n    var current = queue.pop();\n    var children = childrenOfNode(current);\n    if (current === node) return pathFilter(path, hasNode);\n    path.push(current);\n\n    if (children.length === 0) {\n      // leaf node. if it isn't the node we are looking for, we pop.\n      path.pop();\n    }\n\n    queue.push.apply(queue, _toConsumableArray(children));\n  }\n\n  return null;\n}\n\nfunction parentsOfNode(node, root) {\n  return (pathToNode(node, root) || []).reverse();\n}\n\nfunction nodeHasId(node, id) {\n  return propsOfNode(node).id === id;\n}\n\nvar CAN_NEVER_MATCH = {};\n\nfunction replaceUndefined(v) {\n  return typeof v !== 'undefined' ? v : CAN_NEVER_MATCH;\n}\n\nfunction replaceUndefinedValues(obj) {\n  return (0, _object4['default'])(obj).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        k = _ref2[0],\n        v = _ref2[1];\n\n    return (0, _object2['default'])({}, acc, _defineProperty({}, k, replaceUndefined(v)));\n  }, {});\n}\n\nfunction nodeMatchesObjectProps(node, props) {\n  return (0, _isSubset2['default'])(propsOfNode(node), replaceUndefinedValues(props));\n}\n\nfunction getTextFromHostNode(hostNode) {\n  if (typeof hostNode === 'string') {\n    return String(hostNode || '');\n  }\n\n  if (!hostNode) {\n    return '';\n  }\n\n  return hostNode.textContent || '';\n}\n\nfunction getTextFromRSTNode(node, _ref3) {\n  var getCustom = _ref3.getCustom,\n      handleHostNodes = _ref3.handleHostNodes,\n      recurse = _ref3.recurse,\n      _ref3$nullRenderRetur = _ref3.nullRenderReturnsNull,\n      nullRenderReturnsNull = _ref3$nullRenderRetur === undefined ? false : _ref3$nullRenderRetur;\n\n  if (node == null) {\n    return '';\n  }\n\n  if (typeof node === 'string' || typeof node === 'number') {\n    return String(node);\n  }\n\n  if (getCustom && node.type && typeof node.type === 'function') {\n    return getCustom(node);\n  }\n\n  if (handleHostNodes && node.nodeType === 'host') {\n    return handleHostNodes(node);\n  }\n\n  if (node.rendered == null && nullRenderReturnsNull) {\n    return null;\n  }\n\n  return childrenOfNode(node).map(recurse).join('');\n}\n\nfunction getTextFromNode(node) {\n  return getTextFromRSTNode(node, {\n    recurse: getTextFromNode,\n    getCustom: function () {\n      function getCustom(_ref4) {\n        var type = _ref4.type;\n        return '<' + String(type.displayName || (0, _functionPrototype2['default'])(type)) + ' />';\n      }\n\n      return getCustom;\n    }()\n  });\n}\n\nfunction getTextFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse: function () {\n      function recurse(item) {\n        return getTextFromHostNodes(item, adapter);\n      }\n\n      return recurse;\n    }(),\n    handleHostNodes: function () {\n      function handleHostNodes(item) {\n        var nodes = [].concat(adapter.nodeToHostNode(item, true));\n        return nodes.map(getTextFromHostNode).join('');\n      }\n\n      return handleHostNodes;\n    }()\n  });\n}\n\nfunction getHTMLFromHostNode(hostNode) {\n  if (hostNode == null) {\n    return null;\n  }\n\n  return hostNode.outerHTML.replace(/\\sdata-(reactid|reactroot)+=\"([^\"]*)+\"/g, '');\n}\n\nfunction getHTMLFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse: function () {\n      function recurse(item) {\n        return getHTMLFromHostNodes(item, adapter);\n      }\n\n      return recurse;\n    }(),\n    handleHostNodes: function () {\n      function handleHostNodes(item) {\n        var nodes = [].concat(adapter.nodeToHostNode(item, true));\n        return nodes.map(getHTMLFromHostNode).join('');\n      }\n\n      return handleHostNodes;\n    }(),\n    nullRenderReturnsNull: true\n  });\n} //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SU1RUcmF2ZXJzYWwuanMiXSwibmFtZXMiOlsicHJvcHNPZk5vZGUiLCJjaGlsZHJlbk9mTm9kZSIsImhhc0NsYXNzTmFtZSIsInRyZWVGb3JFYWNoIiwidHJlZUZpbHRlciIsImZpbmRQYXJlbnROb2RlIiwicGF0aFRvTm9kZSIsInBhcmVudHNPZk5vZGUiLCJub2RlSGFzSWQiLCJub2RlTWF0Y2hlc09iamVjdFByb3BzIiwiZ2V0VGV4dEZyb21Ob2RlIiwiZ2V0VGV4dEZyb21Ib3N0Tm9kZXMiLCJnZXRIVE1MRnJvbUhvc3ROb2RlcyIsIm5vZGUiLCJwcm9wcyIsImFkYXB0ZXIiLCJhZGFwdGVySGFzSXNGcmFnbWVudCIsImlzRnJhZ21lbnQiLCJyZW5kZXJlZEFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwicmVuZGVyZWQiLCJtYXAiLCJjdXJyZW50Q2hpbGQiLCJjbGFzc05hbWUiLCJjbGFzc2VzIiwiU3RyaW5nIiwicmVwbGFjZSIsInRlc3QiLCJpbmRleE9mIiwidHJlZSIsImZuIiwiZm9yRWFjaCIsInJlc3VsdHMiLCJwdXNoIiwicm9vdCIsInRhcmdldE5vZGUiLCJwYXRoRmlsdGVyIiwicGF0aCIsImZpbHRlciIsImxlbmd0aCIsInF1ZXVlIiwiaGFzTm9kZSIsInRlc3ROb2RlIiwiY3VycmVudCIsInBvcCIsImNoaWxkcmVuIiwicmV2ZXJzZSIsImlkIiwiQ0FOX05FVkVSX01BVENIIiwicmVwbGFjZVVuZGVmaW5lZCIsInYiLCJyZXBsYWNlVW5kZWZpbmVkVmFsdWVzIiwib2JqIiwicmVkdWNlIiwiYWNjIiwiayIsImdldFRleHRGcm9tSG9zdE5vZGUiLCJob3N0Tm9kZSIsInRleHRDb250ZW50IiwiZ2V0VGV4dEZyb21SU1ROb2RlIiwiZ2V0Q3VzdG9tIiwiaGFuZGxlSG9zdE5vZGVzIiwicmVjdXJzZSIsIm51bGxSZW5kZXJSZXR1cm5zTnVsbCIsInR5cGUiLCJub2RlVHlwZSIsImpvaW4iLCJkaXNwbGF5TmFtZSIsIml0ZW0iLCJub2RlcyIsImNvbmNhdCIsIm5vZGVUb0hvc3ROb2RlIiwiZ2V0SFRNTEZyb21Ib3N0Tm9kZSIsIm91dGVySFRNTCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7UUFPZ0JBLFcsR0FBQUEsVztRQUlBQyxjLEdBQUFBLGM7UUF1QkFDLFksR0FBQUEsWTtRQU9BQyxXLEdBQUFBLFc7UUFPQUMsVSxHQUFBQSxVO1FBb0JBQyxjLEdBQUFBLGM7UUFrQkFDLFUsR0FBQUEsVTtRQXVCQUMsYSxHQUFBQSxhO1FBSUFDLFMsR0FBQUEsUztRQWFBQyxzQixHQUFBQSxzQjtRQXlDQUMsZSxHQUFBQSxlO1FBU0FDLG9CLEdBQUFBLG9CO1FBbUJBQyxvQixHQUFBQSxvQjs7Ozs7O0FBbk1oQjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7QUFFTyxTQUFTWixXQUFULENBQXFCYSxJQUFyQixFQUEyQjtBQUNoQyxTQUFRQSxRQUFRQSxLQUFLQyxLQUFkLElBQXdCLEVBQS9CO0FBQ0Q7O0FBRU0sU0FBU2IsY0FBVCxDQUF3QlksSUFBeEIsRUFBOEI7QUFDbkMsTUFBSSxDQUFDQSxJQUFMLEVBQVcsT0FBTyxFQUFQOztBQUVYLE1BQU1FLFVBQVUsOEJBQWhCO0FBQ0EsTUFBTUMsdUJBQXVCRCxRQUFRRSxVQUFSLElBQXNCLE9BQU9GLFFBQVFFLFVBQWYsS0FBOEIsVUFBakY7O0FBRUEsTUFBTUMsZ0JBQWdCQyxNQUFNQyxPQUFOLENBQWNQLEtBQUtRLFFBQW5CLElBQStCLGlDQUFLUixLQUFLUSxRQUFWLEVBQW9CLENBQXBCLENBQS9CLEdBQXdELENBQUNSLEtBQUtRLFFBQU4sQ0FBOUU7O0FBRUE7QUFDQSxNQUFJLENBQUNMLG9CQUFMLEVBQTJCO0FBQ3pCLFdBQU9FLGFBQVA7QUFDRDs7QUFFRCxTQUFPLGlDQUFLQSxjQUFjSSxHQUFkLENBQWtCLFVBQUNDLFlBQUQsRUFBa0I7QUFDOUM7QUFDQSxRQUFJUixRQUFRRSxVQUFSLENBQW1CTSxZQUFuQixDQUFKLEVBQXNDO0FBQ3BD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LElBQS9CLENBQW9DLEVBQXBDLENBQVA7QUFDRDs7QUFQNkI7QUFBQTs7QUFROUJILDJCQUF1QjtBQVJPLEdBQXpCLENBQVA7QUFVRCIsImZpbGUiOiJSU1RUcmF2ZXJzYWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZmxhdCBmcm9tICdhcnJheS5wcm90b3R5cGUuZmxhdCc7XG5pbXBvcnQgZW50cmllcyBmcm9tICdvYmplY3QuZW50cmllcyc7XG5pbXBvcnQgaXNTdWJzZXQgZnJvbSAnaXMtc3Vic2V0JztcbmltcG9ydCBmdW5jdGlvbk5hbWUgZnJvbSAnZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUnO1xuaW1wb3J0IGlzUmVnZXggZnJvbSAnaXMtcmVnZXgnO1xuaW1wb3J0IGdldEFkYXB0ZXIgZnJvbSAnLi9nZXRBZGFwdGVyJztcblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BzT2ZOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlICYmIG5vZGUucHJvcHMpIHx8IHt9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hpbGRyZW5PZk5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBbXTtcblxuICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcigpO1xuICBjb25zdCBhZGFwdGVySGFzSXNGcmFnbWVudCA9IGFkYXB0ZXIuaXNGcmFnbWVudCAmJiB0eXBlb2YgYWRhcHRlci5pc0ZyYWdtZW50ID09PSAnZnVuY3Rpb24nO1xuXG4gIGNvbnN0IHJlbmRlcmVkQXJyYXkgPSBBcnJheS5pc0FycmF5KG5vZGUucmVuZGVyZWQpID8gZmxhdChub2RlLnJlbmRlcmVkLCAxKSA6IFtub2RlLnJlbmRlcmVkXTtcblxuICAvLyBSZWFjdCBhZGFwdGVycyBiZWZvcmUgMTYgd2lsbCBub3QgaGF2ZSBpc0ZyYWdtZW50XG4gIGlmICghYWRhcHRlckhhc0lzRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gcmVuZGVyZWRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBmbGF0KHJlbmRlcmVkQXJyYXkubWFwKChjdXJyZW50Q2hpbGQpID0+IHtcbiAgICAvLyBJZiB0aGUgbm9kZSBpcyBhIEZyYWdtZW50LCB3ZSB3YW50IHRvIHJldHVybiBpdHMgY2hpbGRyZW4sIG5vdCB0aGUgZnJhZ21lbnQgaXRzZWxmXG4gICAgaWYgKGFkYXB0ZXIuaXNGcmFnbWVudChjdXJyZW50Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5PZk5vZGUoY3VycmVudENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudENoaWxkO1xuICB9KSwgMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNDbGFzc05hbWUobm9kZSwgY2xhc3NOYW1lKSB7XG4gIGxldCBjbGFzc2VzID0gcHJvcHNPZk5vZGUobm9kZSkuY2xhc3NOYW1lIHx8ICcnO1xuICBjbGFzc2VzID0gU3RyaW5nKGNsYXNzZXMpLnJlcGxhY2UoL1xccy9nLCAnICcpO1xuICBpZiAoaXNSZWdleChjbGFzc05hbWUpKSByZXR1cm4gY2xhc3NOYW1lLnRlc3QoY2xhc3Nlcyk7XG4gIHJldHVybiBgICR7Y2xhc3Nlc30gYC5pbmRleE9mKGAgJHtjbGFzc05hbWV9IGApID4gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmVlRm9yRWFjaCh0cmVlLCBmbikge1xuICBpZiAodHJlZSkge1xuICAgIGZuKHRyZWUpO1xuICB9XG4gIGNoaWxkcmVuT2ZOb2RlKHRyZWUpLmZvckVhY2goKG5vZGUpID0+IHRyZWVGb3JFYWNoKG5vZGUsIGZuKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmVlRmlsdGVyKHRyZWUsIGZuKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgdHJlZUZvckVhY2godHJlZSwgKG5vZGUpID0+IHtcbiAgICBpZiAoZm4obm9kZSkpIHtcbiAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBUbyBzdXBwb3J0IHNpYmxpbmcgc2VsZWN0b3JzIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBmaW5kXG4gKiB0aGUgc2libGluZ3Mgb2YgYSBub2RlLiBUaGUgZWFzaWVzdCB3YXkgdG8gZG8gdGhhdCBpcyBmaW5kXG4gKiB0aGUgcGFyZW50IG9mIHRoZSBub2RlIGFuZCBhY2Nlc3MgaXRzIGNoaWxkcmVuLlxuICpcbiAqIFRoaXMgd291bGQgYmUgdW5uZWVkZWQgaWYgdGhlIFJTVCBzcGVjIGluY2x1ZGVkIHNpYmxpbmcgcG9pbnRlcnNcbiAqIHN1Y2ggYXMgbm9kZS5uZXh0U2libGluZyBhbmQgbm9kZS5wcmV2U2libGluZ1xuICogQHBhcmFtIHsqfSByb290XG4gKiBAcGFyYW0geyp9IHRhcmdldE5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlKHJvb3QsIHRhcmdldE5vZGUpIHtcbiAgY29uc3QgcmVzdWx0cyA9IHRyZWVGaWx0ZXIoXG4gICAgcm9vdCxcbiAgICAobm9kZSkgPT4ge1xuICAgICAgaWYgKCFub2RlLnJlbmRlcmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoaWxkcmVuT2ZOb2RlKG5vZGUpLmluZGV4T2YodGFyZ2V0Tm9kZSkgIT09IC0xO1xuICAgIH0sXG4gICk7XG4gIHJldHVybiByZXN1bHRzWzBdIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhdGhGaWx0ZXIocGF0aCwgZm4pIHtcbiAgcmV0dXJuIHBhdGguZmlsdGVyKCh0cmVlKSA9PiB0cmVlRmlsdGVyKHRyZWUsIGZuKS5sZW5ndGggIT09IDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0aFRvTm9kZShub2RlLCByb290KSB7XG4gIGNvbnN0IHF1ZXVlID0gW3Jvb3RdO1xuICBjb25zdCBwYXRoID0gW107XG5cbiAgY29uc3QgaGFzTm9kZSA9ICh0ZXN0Tm9kZSkgPT4gbm9kZSA9PT0gdGVzdE5vZGU7XG5cbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBxdWV1ZS5wb3AoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNoaWxkcmVuT2ZOb2RlKGN1cnJlbnQpO1xuICAgIGlmIChjdXJyZW50ID09PSBub2RlKSByZXR1cm4gcGF0aEZpbHRlcihwYXRoLCBoYXNOb2RlKTtcblxuICAgIHBhdGgucHVzaChjdXJyZW50KTtcblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGxlYWYgbm9kZS4gaWYgaXQgaXNuJ3QgdGhlIG5vZGUgd2UgYXJlIGxvb2tpbmcgZm9yLCB3ZSBwb3AuXG4gICAgICBwYXRoLnBvcCgpO1xuICAgIH1cbiAgICBxdWV1ZS5wdXNoKC4uLmNoaWxkcmVuKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyZW50c09mTm9kZShub2RlLCByb290KSB7XG4gIHJldHVybiAocGF0aFRvTm9kZShub2RlLCByb290KSB8fCBbXSkucmV2ZXJzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZUhhc0lkKG5vZGUsIGlkKSB7XG4gIHJldHVybiBwcm9wc09mTm9kZShub2RlKS5pZCA9PT0gaWQ7XG59XG5cbmNvbnN0IENBTl9ORVZFUl9NQVRDSCA9IHt9O1xuZnVuY3Rpb24gcmVwbGFjZVVuZGVmaW5lZCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiAhPT0gJ3VuZGVmaW5lZCcgPyB2IDogQ0FOX05FVkVSX01BVENIO1xufVxuZnVuY3Rpb24gcmVwbGFjZVVuZGVmaW5lZFZhbHVlcyhvYmopIHtcbiAgcmV0dXJuIGVudHJpZXMob2JqKVxuICAgIC5yZWR1Y2UoKGFjYywgW2ssIHZdKSA9PiAoeyAuLi5hY2MsIFtrXTogcmVwbGFjZVVuZGVmaW5lZCh2KSB9KSwge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZU1hdGNoZXNPYmplY3RQcm9wcyhub2RlLCBwcm9wcykge1xuICByZXR1cm4gaXNTdWJzZXQocHJvcHNPZk5vZGUobm9kZSksIHJlcGxhY2VVbmRlZmluZWRWYWx1ZXMocHJvcHMpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEZyb21Ib3N0Tm9kZShob3N0Tm9kZSkge1xuICBpZiAodHlwZW9mIGhvc3ROb2RlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBTdHJpbmcoaG9zdE5vZGUgfHwgJycpO1xuICB9XG4gIGlmICghaG9zdE5vZGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIGhvc3ROb2RlLnRleHRDb250ZW50IHx8ICcnO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0RnJvbVJTVE5vZGUobm9kZSwge1xuICBnZXRDdXN0b20sXG4gIGhhbmRsZUhvc3ROb2RlcyxcbiAgcmVjdXJzZSxcbiAgbnVsbFJlbmRlclJldHVybnNOdWxsID0gZmFsc2UsXG59KSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBTdHJpbmcobm9kZSk7XG4gIH1cblxuICBpZiAoZ2V0Q3VzdG9tICYmIG5vZGUudHlwZSAmJiB0eXBlb2Ygbm9kZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdldEN1c3RvbShub2RlKTtcbiAgfVxuXG4gIGlmIChoYW5kbGVIb3N0Tm9kZXMgJiYgbm9kZS5ub2RlVHlwZSA9PT0gJ2hvc3QnKSB7XG4gICAgcmV0dXJuIGhhbmRsZUhvc3ROb2Rlcyhub2RlKTtcbiAgfVxuICBpZiAobm9kZS5yZW5kZXJlZCA9PSBudWxsICYmIG51bGxSZW5kZXJSZXR1cm5zTnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjaGlsZHJlbk9mTm9kZShub2RlKS5tYXAocmVjdXJzZSkuam9pbignJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0RnJvbU5vZGUobm9kZSkge1xuICByZXR1cm4gZ2V0VGV4dEZyb21SU1ROb2RlKG5vZGUsIHtcbiAgICByZWN1cnNlOiBnZXRUZXh0RnJvbU5vZGUsXG4gICAgZ2V0Q3VzdG9tKHsgdHlwZSB9KSB7XG4gICAgICByZXR1cm4gYDwke3R5cGUuZGlzcGxheU5hbWUgfHwgZnVuY3Rpb25OYW1lKHR5cGUpfSAvPmA7XG4gICAgfSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXh0RnJvbUhvc3ROb2Rlcyhub2RlLCBhZGFwdGVyKSB7XG4gIHJldHVybiBnZXRUZXh0RnJvbVJTVE5vZGUobm9kZSwge1xuICAgIHJlY3Vyc2UoaXRlbSkge1xuICAgICAgcmV0dXJuIGdldFRleHRGcm9tSG9zdE5vZGVzKGl0ZW0sIGFkYXB0ZXIpO1xuICAgIH0sXG4gICAgaGFuZGxlSG9zdE5vZGVzKGl0ZW0pIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gW10uY29uY2F0KGFkYXB0ZXIubm9kZVRvSG9zdE5vZGUoaXRlbSwgdHJ1ZSkpO1xuICAgICAgcmV0dXJuIG5vZGVzLm1hcChnZXRUZXh0RnJvbUhvc3ROb2RlKS5qb2luKCcnKTtcbiAgICB9LFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SFRNTEZyb21Ib3N0Tm9kZShob3N0Tm9kZSkge1xuICBpZiAoaG9zdE5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBob3N0Tm9kZS5vdXRlckhUTUwucmVwbGFjZSgvXFxzZGF0YS0ocmVhY3RpZHxyZWFjdHJvb3QpKz1cIihbXlwiXSopK1wiL2csICcnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhUTUxGcm9tSG9zdE5vZGVzKG5vZGUsIGFkYXB0ZXIpIHtcbiAgcmV0dXJuIGdldFRleHRGcm9tUlNUTm9kZShub2RlLCB7XG4gICAgcmVjdXJzZShpdGVtKSB7XG4gICAgICByZXR1cm4gZ2V0SFRNTEZyb21Ib3N0Tm9kZXMoaXRlbSwgYWRhcHRlcik7XG4gICAgfSxcbiAgICBoYW5kbGVIb3N0Tm9kZXMoaXRlbSkge1xuICAgICAgY29uc3Qgbm9kZXMgPSBbXS5jb25jYXQoYWRhcHRlci5ub2RlVG9Ib3N0Tm9kZShpdGVtLCB0cnVlKSk7XG4gICAgICByZXR1cm4gbm9kZXMubWFwKGdldEhUTUxGcm9tSG9zdE5vZGUpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgbnVsbFJlbmRlclJldHVybnNOdWxsOiB0cnVlLFxuICB9KTtcbn1cbiJdfQ==","map":{"version":3,"sources":["D:\\React\\todomatic\\node_modules\\enzyme\\src\\RSTTraversal.js"],"names":["propsOfNode","node","childrenOfNode","adapter","adapterHasIsFragment","renderedArray","Array","hasClassName","classes","String","className","treeForEach","fn","treeFilter","results","findParentNode","pathToNode","queue","path","hasNode","current","children","pathFilter","parentsOfNode","nodeHasId","CAN_NEVER_MATCH","k","v","replaceUndefined","nodeMatchesObjectProps","replaceUndefinedValues","hostNode","getCustom","handleHostNodes","recurse","nullRenderReturnsNull","getTextFromNode","type","getTextFromHostNodes","nodes","getHTMLFromHostNodes"],"mappings":"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","sourcesContent":["import flat from 'array.prototype.flat';\nimport entries from 'object.entries';\nimport isSubset from 'is-subset';\nimport functionName from 'function.prototype.name';\nimport isRegex from 'is-regex';\nimport getAdapter from './getAdapter';\n\nexport function propsOfNode(node) {\n  return (node && node.props) || {};\n}\n\nexport function childrenOfNode(node) {\n  if (!node) return [];\n\n  const adapter = getAdapter();\n  const adapterHasIsFragment = adapter.isFragment && typeof adapter.isFragment === 'function';\n\n  const renderedArray = Array.isArray(node.rendered) ? flat(node.rendered, 1) : [node.rendered];\n\n  // React adapters before 16 will not have isFragment\n  if (!adapterHasIsFragment) {\n    return renderedArray;\n  }\n\n  return flat(renderedArray.map((currentChild) => {\n    // If the node is a Fragment, we want to return its children, not the fragment itself\n    if (adapter.isFragment(currentChild)) {\n      return childrenOfNode(currentChild);\n    }\n\n    return currentChild;\n  }), 1);\n}\n\nexport function hasClassName(node, className) {\n  let classes = propsOfNode(node).className || '';\n  classes = String(classes).replace(/\\s/g, ' ');\n  if (isRegex(className)) return className.test(classes);\n  return ` ${classes} `.indexOf(` ${className} `) > -1;\n}\n\nexport function treeForEach(tree, fn) {\n  if (tree) {\n    fn(tree);\n  }\n  childrenOfNode(tree).forEach((node) => treeForEach(node, fn));\n}\n\nexport function treeFilter(tree, fn) {\n  const results = [];\n  treeForEach(tree, (node) => {\n    if (fn(node)) {\n      results.push(node);\n    }\n  });\n  return results;\n}\n\n/**\n * To support sibling selectors we need to be able to find\n * the siblings of a node. The easiest way to do that is find\n * the parent of the node and access its children.\n *\n * This would be unneeded if the RST spec included sibling pointers\n * such as node.nextSibling and node.prevSibling\n * @param {*} root\n * @param {*} targetNode\n */\nexport function findParentNode(root, targetNode) {\n  const results = treeFilter(\n    root,\n    (node) => {\n      if (!node.rendered) {\n        return false;\n      }\n\n      return childrenOfNode(node).indexOf(targetNode) !== -1;\n    },\n  );\n  return results[0] || null;\n}\n\nfunction pathFilter(path, fn) {\n  return path.filter((tree) => treeFilter(tree, fn).length !== 0);\n}\n\nexport function pathToNode(node, root) {\n  const queue = [root];\n  const path = [];\n\n  const hasNode = (testNode) => node === testNode;\n\n  while (queue.length) {\n    const current = queue.pop();\n    const children = childrenOfNode(current);\n    if (current === node) return pathFilter(path, hasNode);\n\n    path.push(current);\n\n    if (children.length === 0) {\n      // leaf node. if it isn't the node we are looking for, we pop.\n      path.pop();\n    }\n    queue.push(...children);\n  }\n\n  return null;\n}\n\nexport function parentsOfNode(node, root) {\n  return (pathToNode(node, root) || []).reverse();\n}\n\nexport function nodeHasId(node, id) {\n  return propsOfNode(node).id === id;\n}\n\nconst CAN_NEVER_MATCH = {};\nfunction replaceUndefined(v) {\n  return typeof v !== 'undefined' ? v : CAN_NEVER_MATCH;\n}\nfunction replaceUndefinedValues(obj) {\n  return entries(obj)\n    .reduce((acc, [k, v]) => ({ ...acc, [k]: replaceUndefined(v) }), {});\n}\n\nexport function nodeMatchesObjectProps(node, props) {\n  return isSubset(propsOfNode(node), replaceUndefinedValues(props));\n}\n\nfunction getTextFromHostNode(hostNode) {\n  if (typeof hostNode === 'string') {\n    return String(hostNode || '');\n  }\n  if (!hostNode) {\n    return '';\n  }\n  return hostNode.textContent || '';\n}\n\nfunction getTextFromRSTNode(node, {\n  getCustom,\n  handleHostNodes,\n  recurse,\n  nullRenderReturnsNull = false,\n}) {\n  if (node == null) {\n    return '';\n  }\n\n  if (typeof node === 'string' || typeof node === 'number') {\n    return String(node);\n  }\n\n  if (getCustom && node.type && typeof node.type === 'function') {\n    return getCustom(node);\n  }\n\n  if (handleHostNodes && node.nodeType === 'host') {\n    return handleHostNodes(node);\n  }\n  if (node.rendered == null && nullRenderReturnsNull) {\n    return null;\n  }\n  return childrenOfNode(node).map(recurse).join('');\n}\n\nexport function getTextFromNode(node) {\n  return getTextFromRSTNode(node, {\n    recurse: getTextFromNode,\n    getCustom({ type }) {\n      return `<${type.displayName || functionName(type)} />`;\n    },\n  });\n}\n\nexport function getTextFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getTextFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getTextFromHostNode).join('');\n    },\n  });\n}\n\nfunction getHTMLFromHostNode(hostNode) {\n  if (hostNode == null) {\n    return null;\n  }\n  return hostNode.outerHTML.replace(/\\sdata-(reactid|reactroot)+=\"([^\"]*)+\"/g, '');\n}\n\nexport function getHTMLFromHostNodes(node, adapter) {\n  return getTextFromRSTNode(node, {\n    recurse(item) {\n      return getHTMLFromHostNodes(item, adapter);\n    },\n    handleHostNodes(item) {\n      const nodes = [].concat(adapter.nodeToHostNode(item, true));\n      return nodes.map(getHTMLFromHostNode).join('');\n    },\n    nullRenderReturnsNull: true,\n  });\n}\n"]},"metadata":{},"sourceType":"script"}