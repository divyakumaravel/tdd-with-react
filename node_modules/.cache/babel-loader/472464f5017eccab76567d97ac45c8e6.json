{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.buildPredicate = buildPredicate;\nexports.reduceTreeBySelector = reduceTreeBySelector;\nexports.reduceTreesBySelector = reduceTreesBySelector;\n\nvar _rstSelectorParser = require('rst-selector-parser');\n\nvar _object = require('object.values');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayPrototype = require('array.prototype.flat');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _objectIs = require('object-is');\n\nvar _objectIs2 = _interopRequireDefault(_objectIs);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _byConstructor = require('html-element-map/byConstructor');\n\nvar _byConstructor2 = _interopRequireDefault(_byConstructor);\n\nvar _RSTTraversal = require('./RSTTraversal');\n\nvar _Utils = require('./Utils');\n\nvar _getAdapter = require('./getAdapter');\n\nvar _getAdapter2 = _interopRequireDefault(_getAdapter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} // our CSS selector parser instance\n\n\nvar parser = (0, _rstSelectorParser.createParser)(); // Combinators that allow you to chance selectors\n\nvar CHILD = 'childCombinator';\nvar ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nvar GENERAL_SIBLING = 'generalSiblingCombinator';\nvar DESCENDANT = 'descendantCombinator'; // Selectors for targeting elements\n\nvar SELECTOR = 'selector';\nvar TYPE_SELECTOR = 'typeSelector';\nvar CLASS_SELECTOR = 'classSelector';\nvar ID_SELECTOR = 'idSelector';\nvar UNIVERSAL_SELECTOR = 'universalSelector';\nvar ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nvar ATTRIBUTE_VALUE = 'attributeValueSelector'; // @TODO we dont support these, throw if they are used\n\nvar PSEUDO_CLASS = 'pseudoClassSelector';\nvar PSEUDO_ELEMENT = 'pseudoElementSelector';\nvar EXACT_ATTRIBUTE_OPERATOR = '=';\nvar WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nvar HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nvar PREFIX_ATTRIBUTE_OPERATOR = '^=';\nvar SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nvar SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\nfunction unique(arr) {\n  return [].concat(_toConsumableArray(new Set(arr)));\n}\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\n\n\nfunction uniqueReduce(fn, nodes) {\n  return unique(nodes.reduce(fn, []));\n}\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\n\n\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error('Failed to parse selector: ' + String(selector));\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  var operator = token.operator,\n      value = token.value,\n      name = token.name;\n  var nodeProps = (0, _Utils.propsOfNode)(node);\n  var descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n\n  var nodePropValue = nodeProps[name];\n\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return (0, _has2['default'])(nodeProps, token.name);\n  } // Only the exact value operator (\"=\") can match non-strings\n\n\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return (0, _objectIs2['default'])(nodePropValue, value);\n\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(String(value) + '-');\n\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n\n    default:\n      throw new Error('Enzyme::Selector: Unknown attribute selector operator \"' + String(operator) + '\"');\n  }\n}\n\nfunction matchPseudoSelector(node, token, root) {\n  var name = token.name,\n      parameters = token.parameters;\n\n  if (name === 'not') {\n    // eslint-disable-next-line no-use-before-define\n    return parameters.every(function (selector) {\n      return reduceTreeBySelector(selector, node).length === 0;\n    });\n  }\n\n  if (name === 'empty') {\n    return (0, _RSTTraversal.treeFilter)(node, function (n) {\n      return n !== node;\n    }).length === 0;\n  }\n\n  if (name === 'first-child') {\n    var _findParentNode = (0, _RSTTraversal.findParentNode)(root, node),\n        rendered = _findParentNode.rendered;\n\n    var _rendered = _slicedToArray(rendered, 1),\n        firstChild = _rendered[0];\n\n    return firstChild === node;\n  }\n\n  if (name === 'last-child') {\n    var _findParentNode2 = (0, _RSTTraversal.findParentNode)(root, node),\n        _rendered2 = _findParentNode2.rendered;\n\n    return _rendered2[_rendered2.length - 1] === node;\n  }\n\n  if (name === 'focus') {\n    if (typeof document === 'undefined') {\n      throw new Error('Enzyme::Selector does not support the \":focus\" pseudo-element without a global `document`.');\n    }\n\n    var adapter = (0, _getAdapter2['default'])();\n    /* eslint-env browser */\n\n    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;\n  }\n\n  throw new TypeError('Enzyme::Selector does not support the \"' + String(token.name) + '\" pseudo-element or pseudo-class selectors.');\n}\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\n\n\nfunction nodeMatchesToken(node, token, root) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n\n  switch (token.type) {\n    /**\n     * Match every node\n     * @example '*' matches every node\n     */\n    case UNIVERSAL_SELECTOR:\n      return true;\n\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n\n    case CLASS_SELECTOR:\n      return (0, _RSTTraversal.hasClassName)(node, token.name);\n\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n\n    case TYPE_SELECTOR:\n      return (0, _Utils.nodeHasType)(node, token.name);\n\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n\n    case ID_SELECTOR:\n      return (0, _RSTTraversal.nodeHasId)(node, token.name);\n\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      return matchPseudoSelector(node, token, root);\n\n    default:\n      throw new Error('Unknown token type: ' + String(token.type));\n  }\n}\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\n\n\nfunction buildPredicateFromToken(token, root) {\n  return function (node) {\n    return token.body.every(function (bodyToken) {\n      return nodeMatchesToken(node, bodyToken, root);\n    });\n  };\n}\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\n\n\nfunction isComplexSelector(tokens) {\n  return tokens.some(function (token) {\n    return token.type !== SELECTOR;\n  });\n}\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {EnzymeSelector} selector\n */\n\n\nfunction buildPredicate(selector) {\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    var tokens = safelyGenerateTokens(selector);\n\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    } // Simple selectors only have a single selector token\n\n\n    return buildPredicateFromToken(tokens[0]);\n  } // If the selector is an element type, check if the node's type matches\n\n\n  var adapter = (0, _getAdapter2['default'])();\n  var isElementType = adapter.isValidElementType ? adapter.isValidElementType(selector) : typeof selector === 'function';\n\n  if (isElementType) {\n    return function (node) {\n      return adapter.matchesElementType(node, selector);\n    };\n  } // If the selector is an non-empty object, treat the keys/values as props\n\n\n  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {\n    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {\n      var hasUndefinedValues = (0, _object2['default'])(selector).some(function (value) {\n        return typeof value === 'undefined';\n      });\n\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n\n      return function (node) {\n        return (0, _RSTTraversal.nodeMatchesObjectProps)(node, selector);\n      };\n    }\n\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n\n  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');\n}\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\n\n\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce(function (matches, node) {\n    var parent = (0, _RSTTraversal.findParentNode)(root, node); // If there's no parent, there's no siblings\n\n    if (!parent) {\n      return matches;\n    }\n\n    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);\n    var nodeIndex = parentChildren.indexOf(node);\n    var adjacentSibling = parentChildren[nodeIndex + 1]; // No sibling\n\n    if (!adjacentSibling) {\n      return matches;\n    }\n\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n\n    return matches;\n  }, []);\n}\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\n\n\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce(function (matches, node) {\n    var parent = (0, _RSTTraversal.findParentNode)(root, node);\n\n    if (!parent) {\n      return matches;\n    }\n\n    var parentChildren = (0, _RSTTraversal.childrenOfNode)(parent);\n    var nodeIndex = parentChildren.indexOf(node);\n    var youngerSiblings = parentChildren.slice(nodeIndex + 1);\n    return matches.concat(youngerSiblings.filter(predicate));\n  }, nodes);\n}\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\n\n\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(function (matches, node) {\n    return matches.concat((0, _RSTTraversal.childrenOfNode)(node).filter(predicate));\n  }, nodes);\n}\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\n\n\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(function (matches, node) {\n    return matches.concat((0, _RSTTraversal.treeFilter)(node, predicate));\n  }, (0, _arrayPrototype2['default'])(nodes.map(_RSTTraversal.childrenOfNode)));\n}\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n *\n * @param {EnzymeSelector} selector\n * @param {RSTNode} root\n */\n\n\nfunction reduceTreeBySelector(selector, root) {\n  if (typeof selector !== 'string') {\n    var elements = (0, _byConstructor2['default'])(selector);\n\n    if (elements.length > 0) {\n      return (0, _arrayPrototype2['default'])(elements.map(function (x) {\n        return reduceTreeBySelector(x.tag, root);\n      })); // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved\n      // const htmlTagNames = elements.map(x => x.tag).join(', ');\n      // return reduceTreeBySelector(htmlTagNames, root);\n    }\n  }\n\n  if (typeof selector === 'function' || (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) === 'object') {\n    return (0, _RSTTraversal.treeFilter)(root, buildPredicate(selector));\n  }\n\n  var results = [];\n\n  if (typeof selector === 'string') {\n    var tokens = safelyGenerateTokens(selector);\n    var index = 0;\n\n    while (index < tokens.length) {\n      var token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can traverse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjacent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n\n      if (token.type === SELECTOR) {\n        var predicate = buildPredicateFromToken(token, root);\n        results = results.concat((0, _RSTTraversal.treeFilter)(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        var type = token.type; // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n\n        index += 1;\n\n        var _predicate = buildPredicateFromToken(tokens[index], root); // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n\n\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, _predicate, root);\n            break;\n          // The ~ combinator\n\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, _predicate, root);\n            break;\n          // The > combinator\n\n          case CHILD:\n            results = matchDirectChild(results, _predicate);\n            break;\n          // The ' ' (whitespace) combinator\n\n          case DESCENDANT:\n            {\n              results = matchDescendant(results, _predicate);\n              break;\n            }\n\n          default:\n            throw new Error('Unknown combinator selector: ' + String(type));\n        }\n      }\n\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n\n  return results;\n}\n\nfunction reduceTreesBySelector(selector, roots) {\n  var results = roots.map(function (n) {\n    return reduceTreeBySelector(selector, n);\n  });\n  return unique((0, _arrayPrototype2['default'])(results, 1));\n} //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zZWxlY3RvcnMuanMiXSwibmFtZXMiOlsiYnVpbGRQcmVkaWNhdGUiLCJyZWR1Y2VUcmVlQnlTZWxlY3RvciIsInJlZHVjZVRyZWVzQnlTZWxlY3RvciIsInBhcnNlciIsIkNISUxEIiwiQURKQUNFTlRfU0lCTElORyIsIkdFTkVSQUxfU0lCTElORyIsIkRFU0NFTkRBTlQiLCJTRUxFQ1RPUiIsIlRZUEVfU0VMRUNUT1IiLCJDTEFTU19TRUxFQ1RPUiIsIklEX1NFTEVDVE9SIiwiVU5JVkVSU0FMX1NFTEVDVE9SIiwiQVRUUklCVVRFX1BSRVNFTkNFIiwiQVRUUklCVVRFX1ZBTFVFIiwiUFNFVURPX0NMQVNTIiwiUFNFVURPX0VMRU1FTlQiLCJFWEFDVF9BVFRSSUJVVEVfT1BFUkFUT1IiLCJXSElURUxJU1RfQVRUUklCVVRFX09QRVJBVE9SIiwiSFlQSEVOQVRFRF9BVFRSSUJVVEVfT1BFUkFUT1IiLCJQUkVGSVhfQVRUUklCVVRFX09QRVJBVE9SIiwiU1VGRklYX0FUVFJJQlVURV9PUEVSQVRPUiIsIlNVQlNUUklOR19BVFRSSUJVVEVfT1BFUkFUT1IiLCJ1bmlxdWUiLCJhcnIiLCJTZXQiLCJ1bmlxdWVSZWR1Y2UiLCJmbiIsIm5vZGVzIiwicmVkdWNlIiwic2FmZWx5R2VuZXJhdGVUb2tlbnMiLCJzZWxlY3RvciIsInBhcnNlIiwiZXJyIiwiRXJyb3IiLCJtYXRjaEF0dHJpYnV0ZVNlbGVjdG9yIiwibm9kZSIsInRva2VuIiwib3BlcmF0b3IiLCJ2YWx1ZSIsIm5hbWUiLCJub2RlUHJvcHMiLCJkZXNjcmlwdG9yIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0Iiwibm9kZVByb3BWYWx1ZSIsInR5cGUiLCJzcGxpdCIsImluZGV4T2YiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJsZW5ndGgiLCJtYXRjaFBzZXVkb1NlbGVjdG9yIiwicm9vdCIsInBhcmFtZXRlcnMiLCJldmVyeSIsIm4iLCJyZW5kZXJlZCIsImZpcnN0Q2hpbGQiLCJkb2N1bWVudCIsImFkYXB0ZXIiLCJhY3RpdmVFbGVtZW50Iiwibm9kZVRvSG9zdE5vZGUiLCJUeXBlRXJyb3IiLCJub2RlTWF0Y2hlc1Rva2VuIiwiYnVpbGRQcmVkaWNhdGVGcm9tVG9rZW4iLCJib2R5IiwiYm9keVRva2VuIiwiaXNDb21wbGV4U2VsZWN0b3IiLCJ0b2tlbnMiLCJzb21lIiwiaXNFbGVtZW50VHlwZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsIm1hdGNoZXNFbGVtZW50VHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJoYXNVbmRlZmluZWRWYWx1ZXMiLCJtYXRjaEFkamFjZW50U2libGluZ3MiLCJwcmVkaWNhdGUiLCJtYXRjaGVzIiwicGFyZW50IiwicGFyZW50Q2hpbGRyZW4iLCJub2RlSW5kZXgiLCJhZGphY2VudFNpYmxpbmciLCJwdXNoIiwibWF0Y2hHZW5lcmFsU2libGluZyIsInlvdW5nZXJTaWJsaW5ncyIsImNvbmNhdCIsImZpbHRlciIsIm1hdGNoRGlyZWN0Q2hpbGQiLCJtYXRjaERlc2NlbmRhbnQiLCJtYXAiLCJjaGlsZHJlbk9mTm9kZSIsImVsZW1lbnRzIiwieCIsInRhZyIsInJlc3VsdHMiLCJpbmRleCIsInJvb3RzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O1FBbVFnQkEsYyxHQUFBQSxjO1FBcUhBQyxvQixHQUFBQSxvQjtRQStFQUMscUIsR0FBQUEscUI7O0FBdmNoQjs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBUUE7O0FBQ0E7Ozs7Ozs7O0FBQ0E7QUFDQSxJQUFNQyxTQUFTLHNDQUFmOztBQUVBO0FBQ0EsSUFBTUMsUUFBUSxpQkFBZDtBQUNBLElBQU1DLG1CQUFtQiwyQkFBekI7QUFDQSxJQUFNQyxrQkFBa0IsMEJBQXhCO0FBQ0EsSUFBTUMsYUFBYSxzQkFBbkI7O0FBRUE7QUFDQSxJQUFNQyxXQUFXLFVBQWpCO0FBQ0EsSUFBTUMsZ0JBQWdCLGNBQXRCO0FBQ0EsSUFBTUMsaUJB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QUNEb0QsZUFBUyxDQUFUO0FBQ0Q7QUFDRixHQXhERCxNQXdETztBQUNMLFVBQU0sSUFBSW5DLFNBQUosQ0FBYyxxRUFBZCxDQUFOO0FBQ0Q7QUFDRCxTQUFPa0MsT0FBUDtBQUNEOztBQUVNLFNBQVNoRyxxQkFBVCxDQUErQjZCLFFBQS9CLEVBQXlDcUUsS0FBekMsRUFBZ0Q7QUFDckQsTUFBTUYsVUFBVUUsTUFBTVAsR0FBTixDQUFVLFVBQUNwQyxDQUFEO0FBQUEsV0FBT3hELHFCQUFxQjhCLFFBQXJCLEVBQStCMEIsQ0FBL0IsQ0FBUDtBQUFBLEdBQVYsQ0FBaEI7QUFDQSxTQUFPbEMsT0FBTyxpQ0FBSzJFLE9BQUwsRUFBYyxDQUFkLENBQVAsQ0FBUDtBQUNEIiwiZmlsZSI6InNlbGVjdG9ycy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVBhcnNlciB9IGZyb20gJ3JzdC1zZWxlY3Rvci1wYXJzZXInO1xuaW1wb3J0IHZhbHVlcyBmcm9tICdvYmplY3QudmFsdWVzJztcbmltcG9ydCBmbGF0IGZyb20gJ2FycmF5LnByb3RvdHlwZS5mbGF0JztcbmltcG9ydCBpcyBmcm9tICdvYmplY3QtaXMnO1xuaW1wb3J0IGhhcyBmcm9tICdoYXMnO1xuaW1wb3J0IGVsZW1lbnRzQnlDb25zdHJ1Y3RvciBmcm9tICdodG1sLWVsZW1lbnQtbWFwL2J5Q29uc3RydWN0b3InO1xuaW1wb3J0IHtcbiAgdHJlZUZpbHRlcixcbiAgbm9kZUhhc0lkLFxuICBmaW5kUGFyZW50Tm9kZSxcbiAgbm9kZU1hdGNoZXNPYmplY3RQcm9wcyxcbiAgY2hpbGRyZW5PZk5vZGUsXG4gIGhhc0NsYXNzTmFtZSxcbn0gZnJvbSAnLi9SU1RUcmF2ZXJzYWwnO1xuaW1wb3J0IHsgbm9kZUhhc1R5cGUsIHByb3BzT2ZOb2RlIH0gZnJvbSAnLi9VdGlscyc7XG5pbXBvcnQgZ2V0QWRhcHRlciBmcm9tICcuL2dldEFkYXB0ZXInO1xuLy8gb3VyIENTUyBzZWxlY3RvciBwYXJzZXIgaW5zdGFuY2VcbmNvbnN0IHBhcnNlciA9IGNyZWF0ZVBhcnNlcigpO1xuXG4vLyBDb21iaW5hdG9ycyB0aGF0IGFsbG93IHlvdSB0byBjaGFuY2Ugc2VsZWN0b3JzXG5jb25zdCBDSElMRCA9ICdjaGlsZENvbWJpbmF0b3InO1xuY29uc3QgQURKQUNFTlRfU0lCTElORyA9ICdhZGphY2VudFNpYmxpbmdDb21iaW5hdG9yJztcbmNvbnN0IEdFTkVSQUxfU0lCTElORyA9ICdnZW5lcmFsU2libGluZ0NvbWJpbmF0b3InO1xuY29uc3QgREVTQ0VOREFOVCA9ICdkZXNjZW5kYW50Q29tYmluYXRvcic7XG5cbi8vIFNlbGVjdG9ycyBmb3IgdGFyZ2V0aW5nIGVsZW1lbnRzXG5jb25zdCBTRUxFQ1RPUiA9ICdzZWxlY3Rvcic7XG5jb25zdCBUWVBFX1NFTEVDVE9SID0gJ3R5cGVTZWxlY3Rvcic7XG5jb25zdCBDTEFTU19TRUxFQ1RPUiA9ICdjbGFzc1NlbGVjdG9yJztcbmNvbnN0IElEX1NFTEVDVE9SID0gJ2lkU2VsZWN0b3InO1xuY29uc3QgVU5JVkVSU0FMX1NFTEVDVE9SID0gJ3VuaXZlcnNhbFNlbGVjdG9yJztcbmNvbnN0IEFUVFJJQlVURV9QUkVTRU5DRSA9ICdhdHRyaWJ1dGVQcmVzZW5jZVNlbGVjdG9yJztcbmNvbnN0IEFUVFJJQlVURV9WQUxVRSA9ICdhdHRyaWJ1dGVWYWx1ZVNlbGVjdG9yJztcbi8vIEBUT0RPIHdlIGRvbnQgc3VwcG9ydCB0aGVzZSwgdGhyb3cgaWYgdGhleSBhcmUgdXNlZFxuY29uc3QgUFNFVURPX0NMQVNTID0gJ3BzZXVkb0NsYXNzU2VsZWN0b3InO1xuY29uc3QgUFNFVURPX0VMRU1FTlQgPSAncHNldWRvRWxlbWVudFNlbGVjdG9yJztcblxuY29uc3QgRVhBQ1RfQVRUUklCVVRFX09QRVJBVE9SID0gJz0nO1xuY29uc3QgV0hJVEVMSVNUX0FUVFJJQlVURV9PUEVSQVRPUiA9ICd+PSc7XG5jb25zdCBIWVBIRU5BVEVEX0FUVFJJQlVURV9PUEVSQVRPUiA9ICd8PSc7XG5jb25zdCBQUkVGSVhfQVRUUklCVVRFX09QRVJBVE9SID0gJ149JztcbmNvbnN0IFNVRkZJWF9BVFRSSUJVVEVfT1BFUkFUT1IgPSAnJD0nO1xuY29uc3QgU1VCU1RSSU5HX0FUVFJJQlVURV9PUEVSQVRPUiA9ICcqPSc7XG5cbmZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGFycildO1xufVxuXG4vKipcbiAqIENhbGxzIHJlZHVjZSBvbiBhIGFycmF5IG9mIG5vZGVzIHdpdGggdGhlIHBhc3NlZFxuICogZnVuY3Rpb24sIHJldHVybmluZyBvbmx5IHVuaXF1ZSByZXN1bHRzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZVJlZHVjZShmbiwgbm9kZXMpIHtcbiAgcmV0dXJuIHVuaXF1ZShub2Rlcy5yZWR1Y2UoZm4sIFtdKSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBDU1Mgc2VsZWN0b3IgYW5kIHJldHVybnMgYSBzZXQgb2YgdG9rZW5zIHBhcnNlZFxuICogYnkgc2NhbHBlbC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICovXG5mdW5jdGlvbiBzYWZlbHlHZW5lcmF0ZVRva2VucyhzZWxlY3Rvcikge1xuICB0cnkge1xuICAgIHJldHVybiBwYXJzZXIucGFyc2Uoc2VsZWN0b3IpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzZWxlY3RvcjogJHtzZWxlY3Rvcn1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaEF0dHJpYnV0ZVNlbGVjdG9yKG5vZGUsIHRva2VuKSB7XG4gIGNvbnN0IHsgb3BlcmF0b3IsIHZhbHVlLCBuYW1lIH0gPSB0b2tlbjtcbiAgY29uc3Qgbm9kZVByb3BzID0gcHJvcHNPZk5vZGUobm9kZSk7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGVQcm9wcywgbmFtZSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZ2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5vZGVQcm9wVmFsdWUgPSBub2RlUHJvcHNbbmFtZV07XG4gIGlmICh0eXBlb2Ygbm9kZVByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRva2VuLnR5cGUgPT09IEFUVFJJQlVURV9QUkVTRU5DRSkge1xuICAgIHJldHVybiBoYXMobm9kZVByb3BzLCB0b2tlbi5uYW1lKTtcbiAgfVxuICAvLyBPbmx5IHRoZSBleGFjdCB2YWx1ZSBvcGVyYXRvciAoXCI9XCIpIGNhbiBtYXRjaCBub24tc3RyaW5nc1xuICBpZiAodHlwZW9mIG5vZGVQcm9wVmFsdWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICBpZiAob3BlcmF0b3IgIT09IEVYQUNUX0FUVFJJQlVURV9PUEVSQVRPUikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUgd2hvc2UgdmFsdWUgaXMgZXhhY3RseSBcInZhbFwiLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW2F0dHI9XCJ2YWxcIl0gbWF0Y2hlcyBhdHRyPVwidmFsXCJcbiAgICAgKi9cbiAgICBjYXNlIEVYQUNUX0FUVFJJQlVURV9PUEVSQVRPUjpcbiAgICAgIHJldHVybiBpcyhub2RlUHJvcFZhbHVlLCB2YWx1ZSk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUgd2hvc2UgdmFsdWUgaXMgYSB3aGl0ZXNwYWNlLXNlcGFyYXRlZFxuICAgICAqIGxpc3Qgb2Ygd29yZHMsIG9uZSBvZiB3aGljaCBpcyBleGFjdGx5XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgW3JlbH49XCJjb3B5cmlnaHRcIl0gbWF0Y2hlcyByZWw9XCJjb3B5cmlnaHQgb3RoZXJcIlxuICAgICAqL1xuICAgIGNhc2UgV0hJVEVMSVNUX0FUVFJJQlVURV9PUEVSQVRPUjpcbiAgICAgIHJldHVybiBub2RlUHJvcFZhbHVlLnNwbGl0KCcgJykuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYW4gZWxlbWVudCB3aXRoIHRoZSBhdHQgYXR0cmlidXRlLCBpdHMgdmFsdWUgZWl0aGVyIGJlaW5nIGV4YWN0bHkgdGhlXG4gICAgICogdmFsdWUgb3IgYmVnaW5uaW5nIHdpdGggdGhlIHZhbHVlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbaHJlZmxhbmd8PVwiZW5cIl0gbWF0Y2hlcyBocmVmbGFuZz1cImVuLVVTXCJcbiAgICAgKi9cbiAgICBjYXNlIEhZUEhFTkFURURfQVRUUklCVVRFX09QRVJBVE9SOlxuICAgICAgcmV0dXJuIG5vZGVQcm9wVmFsdWUgPT09IHZhbHVlIHx8IG5vZGVQcm9wVmFsdWUuc3RhcnRzV2l0aChgJHt2YWx1ZX0tYCk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUgd2hvc2UgdmFsdWUgYmVnaW5zIHdpdGggdGhlIHByZWZpeCB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZyB0aGVuIHRoZSBzZWxlY3RvciBkb2VzIG5vdCByZXByZXNlbnQgYW55dGhpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbdHlwZV49XCJpbWFnZVwiXSBtYXRjaGVzIHR5cGU9XCJpbWFnZW9iamVjdFwiXG4gICAgICovXG4gICAgY2FzZSBQUkVGSVhfQVRUUklCVVRFX09QRVJBVE9SOlxuICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IGZhbHNlIDogbm9kZVByb3BWYWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGgpID09PSB2YWx1ZTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGFuIGVsZW1lbnQgd2l0aCB0aGUgYXR0IGF0dHJpYnV0ZSB3aG9zZSB2YWx1ZSBlbmRzIHdpdGggdGhlIHN1ZmZpeCB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZyB0aGVuIHRoZSBzZWxlY3RvciBkb2VzIG5vdCByZXByZXNlbnQgYW55dGhpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBbdHlwZSQ9XCJpbWFnZVwiXSBtYXRjaGVzIHR5cGU9XCJpbWFnZW9iamVjdFwiXG4gICAgICovXG4gICAgY2FzZSBTVUZGSVhfQVRUUklCVVRFX09QRVJBVE9SOlxuICAgICAgcmV0dXJuIHZhbHVlID09PSAnJyA/IGZhbHNlIDogbm9kZVByb3BWYWx1ZS5zbGljZSgtdmFsdWUubGVuZ3RoKSA9PT0gdmFsdWU7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlbGVtZW50IHdpdGggdGhlIGF0dCBhdHRyaWJ1dGUgd2hvc2UgdmFsdWUgY29udGFpbnMgYXQgbGVhc3Qgb25lXG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIHZhbHVlLiBJZiB2YWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nIHRoZW4gdGhlXG4gICAgICogc2VsZWN0b3IgZG9lcyBub3QgcmVwcmVzZW50IGFueXRoaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogW3RpdGxlKj1cImhlbGxvXCJdIG1hdGNoZXMgdGl0bGU9XCJ3ZWxsIGhlbGxvIHRoZXJlXCJcbiAgICAgKi9cbiAgICBjYXNlIFNVQlNUUklOR19BVFRSSUJVVEVfT1BFUkFUT1I6XG4gICAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gZmFsc2UgOiBub2RlUHJvcFZhbHVlLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnp5bWU6OlNlbGVjdG9yOiBVbmtub3duIGF0dHJpYnV0ZSBzZWxlY3RvciBvcGVyYXRvciBcIiR7b3BlcmF0b3J9XCJgKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIG1hdGNoUHNldWRvU2VsZWN0b3Iobm9kZSwgdG9rZW4sIHJvb3QpIHtcbiAgY29uc3QgeyBuYW1lLCBwYXJhbWV0ZXJzIH0gPSB0b2tlbjtcbiAgaWYgKG5hbWUgPT09ICdub3QnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgcmV0dXJuIHBhcmFtZXRlcnMuZXZlcnkoKHNlbGVjdG9yKSA9PiByZWR1Y2VUcmVlQnlTZWxlY3RvcihzZWxlY3Rvciwgbm9kZSkubGVuZ3RoID09PSAwKTtcbiAgfVxuICBpZiAobmFtZSA9PT0gJ2VtcHR5Jykge1xuICAgIHJldHVybiB0cmVlRmlsdGVyKG5vZGUsIChuKSA9PiBuICE9PSBub2RlKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgaWYgKG5hbWUgPT09ICdmaXJzdC1jaGlsZCcpIHtcbiAgICBjb25zdCB7IHJlbmRlcmVkIH0gPSBmaW5kUGFyZW50Tm9kZShyb290LCBub2RlKTtcbiAgICBjb25zdCBbZmlyc3RDaGlsZF0gPSByZW5kZXJlZDtcbiAgICByZXR1cm4gZmlyc3RDaGlsZCA9PT0gbm9kZTtcbiAgfVxuICBpZiAobmFtZSA9PT0gJ2xhc3QtY2hpbGQnKSB7XG4gICAgY29uc3QgeyByZW5kZXJlZCB9ID0gZmluZFBhcmVudE5vZGUocm9vdCwgbm9kZSk7XG4gICAgcmV0dXJuIHJlbmRlcmVkW3JlbmRlcmVkLmxlbmd0aCAtIDFdID09PSBub2RlO1xuICB9XG4gIGlmIChuYW1lID09PSAnZm9jdXMnKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW56eW1lOjpTZWxlY3RvciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBcIjpmb2N1c1wiIHBzZXVkby1lbGVtZW50IHdpdGhvdXQgYSBnbG9iYWwgYGRvY3VtZW50YC4nKTtcbiAgICB9XG4gICAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIoKTtcbiAgICAvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBhZGFwdGVyLm5vZGVUb0hvc3ROb2RlKG5vZGUpID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRW56eW1lOjpTZWxlY3RvciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBcIiR7dG9rZW4ubmFtZX1cIiBwc2V1ZG8tZWxlbWVudCBvciBwc2V1ZG8tY2xhc3Mgc2VsZWN0b3JzLmApO1xufVxuXG4vKipcbiAqIFRha2VzIGEgbm9kZSBhbmQgYSB0b2tlbiBhbmQgZGV0ZXJtaW5lcyBpZiB0aGUgbm9kZVxuICogbWF0Y2hlcyB0aGUgcHJlZGljYXRlIGRlZmluZWQgYnkgdGhlIHRva2VuLlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICovXG5mdW5jdGlvbiBub2RlTWF0Y2hlc1Rva2VuKG5vZGUsIHRva2VuLCByb290KSB7XG4gIGlmIChub2RlID09PSBudWxsIHx8IHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBNYXRjaCBldmVyeSBub2RlXG4gICAgICogQGV4YW1wbGUgJyonIG1hdGNoZXMgZXZlcnkgbm9kZVxuICAgICAqL1xuICAgIGNhc2UgVU5JVkVSU0FMX1NFTEVDVE9SOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYWdhaW5zdCB0aGUgY2xhc3NOYW1lIHByb3BcbiAgICAgKiBAZXhhbXBsZSAnLmFjdGl2ZScgbWF0Y2hlcyA8ZGl2IGNsYXNzTmFtZT0nYWN0aXZlJyAvPlxuICAgICAqL1xuICAgIGNhc2UgQ0xBU1NfU0VMRUNUT1I6XG4gICAgICByZXR1cm4gaGFzQ2xhc3NOYW1lKG5vZGUsIHRva2VuLm5hbWUpO1xuICAgIC8qKlxuICAgICAqIFNpbXBsZSB0eXBlIG1hdGNoaW5nXG4gICAgICogQGV4YW1wbGUgJ2RpdicgbWF0Y2hlcyA8ZGl2IC8+XG4gICAgICovXG4gICAgY2FzZSBUWVBFX1NFTEVDVE9SOlxuICAgICAgcmV0dXJuIG5vZGVIYXNUeXBlKG5vZGUsIHRva2VuLm5hbWUpO1xuICAgIC8qKlxuICAgICAqIE1hdGNoIGFnYWluc3QgdGhlIGBpZGAgcHJvcFxuICAgICAqIEBleGFtcGxlICcjbmF2JyBtYXRjaGVzIDx1bCBpZD1cIm5hdlwiIC8+XG4gICAgICovXG4gICAgY2FzZSBJRF9TRUxFQ1RPUjpcbiAgICAgIHJldHVybiBub2RlSGFzSWQobm9kZSwgdG9rZW4ubmFtZSk7XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBpZiBhbiBhdHRyaWJ1dGUgaXMgcHJlc2VudCwgcmVnYXJkbGVzc1xuICAgICAqIG9mIGl0cyB2YWx1ZVxuICAgICAqIEBleGFtcGxlICdbZGlzYWJsZWRdJyBtYXRjaGVzIDxhIGRpc2FibGVkIC8+XG4gICAgICovXG4gICAgY2FzZSBBVFRSSUJVVEVfUFJFU0VOQ0U6XG4gICAgICByZXR1cm4gbWF0Y2hBdHRyaWJ1dGVTZWxlY3Rvcihub2RlLCB0b2tlbik7XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyBpZiBhbiBhdHRyaWJ1dGUgaXMgcHJlc2VudCB3aXRoIHRoZVxuICAgICAqIHByb3ZpZGVkIHZhbHVlXG4gICAgICogQGV4YW1wbGUgJ1tkYXRhLWZvbz1mb29dJyBtYXRjaGVzIDxkaXYgZGF0YS1mb289XCJmb29cIiAvPlxuICAgICAqL1xuICAgIGNhc2UgQVRUUklCVVRFX1ZBTFVFOlxuICAgICAgcmV0dXJuIG1hdGNoQXR0cmlidXRlU2VsZWN0b3Iobm9kZSwgdG9rZW4pO1xuICAgIGNhc2UgUFNFVURPX0VMRU1FTlQ6XG4gICAgY2FzZSBQU0VVRE9fQ0xBU1M6XG4gICAgICByZXR1cm4gbWF0Y2hQc2V1ZG9TZWxlY3Rvcihub2RlLCB0b2tlbiwgcm9vdCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0b2tlbiB0eXBlOiAke3Rva2VuLnR5cGV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGFcbiAqIG5vZGUgbWF0Y2hlcyBldmVyeSB0b2tlbiBpbiB0aGUgYm9keSBvZiBhIHNlbGVjdG9yXG4gKiB0b2tlbi5cbiAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUHJlZGljYXRlRnJvbVRva2VuKHRva2VuLCByb290KSB7XG4gIHJldHVybiAobm9kZSkgPT4gdG9rZW4uYm9keS5ldmVyeSgoYm9keVRva2VuKSA9PiBub2RlTWF0Y2hlc1Rva2VuKG5vZGUsIGJvZHlUb2tlbiwgcm9vdCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBhIHBhcnNlZCBzZWxlY3RvciBpcyBhIGNvbXBsZXggc2VsZWN0b3IsIHdoaWNoXG4gKiBpcyBkZWZpbmVkIGFzIGEgc2VsZWN0b3IgdGhhdCBjb250YWlucyBjb21iaW5hdG9ycy5cbiAqIEBwYXJhbSB7QXJyYXk8VG9rZW4+fSB0b2tlbnNcbiAqL1xuZnVuY3Rpb24gaXNDb21wbGV4U2VsZWN0b3IodG9rZW5zKSB7XG4gIHJldHVybiB0b2tlbnMuc29tZSgodG9rZW4pID0+IHRva2VuLnR5cGUgIT09IFNFTEVDVE9SKTtcbn1cblxuXG4vKipcbiAqIFRha2VzIGEgY29tcG9uZW50IGNvbnN0cnVjdG9yLCBvYmplY3QsIG9yIHN0cmluZyByZXByZXNlbnRpbmdcbiAqIGEgc2ltcGxlIHNlbGVjdG9yIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgY2FuXG4gKiBiZSBhcHBsaWVkIHRvIGEgc2luZ2xlIG5vZGUuXG4gKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBzZWxlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRQcmVkaWNhdGUoc2VsZWN0b3IpIHtcbiAgLy8gSWYgdGhlIHNlbGVjdG9yIGlzIGEgc3RyaW5nLCBwYXJzZSBpdCBhcyBhIHNpbXBsZSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBzYWZlbHlHZW5lcmF0ZVRva2VucyhzZWxlY3Rvcik7XG4gICAgaWYgKGlzQ29tcGxleFNlbGVjdG9yKHRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgY29tcGxleCBDU1Mgc2VsZWN0b3JzJyk7XG4gICAgfVxuICAgIC8vIFNpbXBsZSBzZWxlY3RvcnMgb25seSBoYXZlIGEgc2luZ2xlIHNlbGVjdG9yIHRva2VuXG4gICAgcmV0dXJuIGJ1aWxkUHJlZGljYXRlRnJvbVRva2VuKHRva2Vuc1swXSk7XG4gIH1cblxuICAvLyBJZiB0aGUgc2VsZWN0b3IgaXMgYW4gZWxlbWVudCB0eXBlLCBjaGVjayBpZiB0aGUgbm9kZSdzIHR5cGUgbWF0Y2hlc1xuICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcigpO1xuICBjb25zdCBpc0VsZW1lbnRUeXBlID0gYWRhcHRlci5pc1ZhbGlkRWxlbWVudFR5cGVcbiAgICA/IGFkYXB0ZXIuaXNWYWxpZEVsZW1lbnRUeXBlKHNlbGVjdG9yKVxuICAgIDogdHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNFbGVtZW50VHlwZSkge1xuICAgIHJldHVybiAobm9kZSkgPT4gYWRhcHRlci5tYXRjaGVzRWxlbWVudFR5cGUobm9kZSwgc2VsZWN0b3IpO1xuICB9XG4gIC8vIElmIHRoZSBzZWxlY3RvciBpcyBhbiBub24tZW1wdHkgb2JqZWN0LCB0cmVhdCB0aGUga2V5cy92YWx1ZXMgYXMgcHJvcHNcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VsZWN0b3IpICYmIHNlbGVjdG9yICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHNlbGVjdG9yKS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBoYXNVbmRlZmluZWRWYWx1ZXMgPSB2YWx1ZXMoc2VsZWN0b3IpLnNvbWUoKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKTtcbiAgICAgIGlmIChoYXNVbmRlZmluZWRWYWx1ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW56eW1lOjpQcm9wcyBjYW7igJl0IGhhdmUgYHVuZGVmaW5lZGAgdmFsdWVzLiBUcnkgdXNpbmcg4oCYZmluZFdoZXJlKCnigJkgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobm9kZSkgPT4gbm9kZU1hdGNoZXNPYmplY3RQcm9wcyhub2RlLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuenltZTo6U2VsZWN0b3IgZG9lcyBub3Qgc3VwcG9ydCBhbiBhcnJheSwgbnVsbCwgb3IgZW1wdHkgb2JqZWN0IGFzIGEgc2VsZWN0b3InKTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuenltZTo6U2VsZWN0b3IgZXhwZWN0cyBhIHN0cmluZywgb2JqZWN0LCBvciB2YWxpZCBlbGVtZW50IHR5cGUgKENvbXBvbmVudCBDb25zdHJ1Y3RvciknKTtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIG9ubHkgbm9kZXMgd2hpY2ggYXJlIGFkamFjZW50IHNpYmxpbmdzIChkaXJlY3QgbmV4dCBzaWJsaW5nKVxuICogYWdhaW5zdCBhIHByZWRpY2F0ZSwgcmV0dXJuaW5nIHRob3NlIHRoYXQgbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2Rlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gKiBAcGFyYW0ge05vZGV9IHJvb3RcbiAqL1xuZnVuY3Rpb24gbWF0Y2hBZGphY2VudFNpYmxpbmdzKG5vZGVzLCBwcmVkaWNhdGUsIHJvb3QpIHtcbiAgcmV0dXJuIG5vZGVzLnJlZHVjZSgobWF0Y2hlcywgbm9kZSkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGZpbmRQYXJlbnROb2RlKHJvb3QsIG5vZGUpO1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB0aGVyZSdzIG5vIHNpYmxpbmdzXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRDaGlsZHJlbiA9IGNoaWxkcmVuT2ZOb2RlKHBhcmVudCk7XG4gICAgY29uc3Qgbm9kZUluZGV4ID0gcGFyZW50Q2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICBjb25zdCBhZGphY2VudFNpYmxpbmcgPSBwYXJlbnRDaGlsZHJlbltub2RlSW5kZXggKyAxXTtcbiAgICAvLyBObyBzaWJsaW5nXG4gICAgaWYgKCFhZGphY2VudFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cbiAgICBpZiAocHJlZGljYXRlKGFkamFjZW50U2libGluZykpIHtcbiAgICAgIG1hdGNoZXMucHVzaChhZGphY2VudFNpYmxpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfSwgW10pO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgb25seSBub2RlcyB3aGljaCBhcmUgZ2VuZXJhbCBzaWJsaW5ncyAoYW55IHNpYmxpbmcgKmFmdGVyKilcbiAqIGFnYWluc3QgYSBwcmVkaWNhdGUsIHJldHVybmluZyB0aG9zZSB0aGF0IG1hdGNoLlxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICogQHBhcmFtIHtOb2RlfSByb290XG4gKi9cbmZ1bmN0aW9uIG1hdGNoR2VuZXJhbFNpYmxpbmcobm9kZXMsIHByZWRpY2F0ZSwgcm9vdCkge1xuICByZXR1cm4gdW5pcXVlUmVkdWNlKChtYXRjaGVzLCBub2RlKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gZmluZFBhcmVudE5vZGUocm9vdCwgbm9kZSk7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRDaGlsZHJlbiA9IGNoaWxkcmVuT2ZOb2RlKHBhcmVudCk7XG4gICAgY29uc3Qgbm9kZUluZGV4ID0gcGFyZW50Q2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICBjb25zdCB5b3VuZ2VyU2libGluZ3MgPSBwYXJlbnRDaGlsZHJlbi5zbGljZShub2RlSW5kZXggKyAxKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5jb25jYXQoeW91bmdlclNpYmxpbmdzLmZpbHRlcihwcmVkaWNhdGUpKTtcbiAgfSwgbm9kZXMpO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgb25seSBub2RlcyB3aGljaCBhcmUgZGlyZWN0IGNoaWxkcmVuIChub3QgZ3JhbmRjaGlsZHJlbiwgZXRjLilcbiAqIGFnYWluc3QgYSBwcmVkaWNhdGUsIHJldHVybmluZyB0aG9zZSB0aGF0IG1hdGNoLlxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICovXG5mdW5jdGlvbiBtYXRjaERpcmVjdENoaWxkKG5vZGVzLCBwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIHVuaXF1ZVJlZHVjZShcbiAgICAobWF0Y2hlcywgbm9kZSkgPT4gbWF0Y2hlcy5jb25jYXQoY2hpbGRyZW5PZk5vZGUobm9kZSkuZmlsdGVyKHByZWRpY2F0ZSkpLFxuICAgIG5vZGVzLFxuICApO1xufVxuXG4vKipcbiAqIE1hdGNoZXMgYWxsIGRlc2NlbmRhbnQgbm9kZXMgYWdhaW5zdCBhIHByZWRpY2F0ZSxcbiAqIHJldHVybmluZyB0aG9zZSB0aGF0IG1hdGNoLlxuICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICovXG5mdW5jdGlvbiBtYXRjaERlc2NlbmRhbnQobm9kZXMsIHByZWRpY2F0ZSkge1xuICByZXR1cm4gdW5pcXVlUmVkdWNlKFxuICAgIChtYXRjaGVzLCBub2RlKSA9PiBtYXRjaGVzLmNvbmNhdCh0cmVlRmlsdGVyKG5vZGUsIHByZWRpY2F0ZSkpLFxuICAgIGZsYXQobm9kZXMubWFwKGNoaWxkcmVuT2ZOb2RlKSksXG4gICk7XG59XG5cbi8qKlxuICogVGFrZXMgYW4gUlNUIGFuZCByZWR1Y2VzIGl0IHRvIGEgc2V0IG9mIG5vZGVzIG1hdGNoaW5nXG4gKiB0aGUgc2VsZWN0b3IuIFRoZSBzZWxlY3RvciBjYW4gYmUgYSBzaW1wbGUgc2VsZWN0b3IsIHdoaWNoXG4gKiBpcyBoYW5kbGVkIGJ5IGBidWlsZFByZWRpY2F0ZWAsIG9yIGEgY29tcGxleCBDU1Mgc2VsZWN0b3Igd2hpY2hcbiAqIHJlZHVjZVRyZWVCeVNlbGVjdG9yIHBhcnNlcyBhbmQgcmVkdWNlcyB0aGUgdHJlZSBiYXNlZCBvbiB0aGUgY29tYmluYXRvcnMuXG4gKlxuICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAqIEBwYXJhbSB7UlNUTm9kZX0gcm9vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlVHJlZUJ5U2VsZWN0b3Ioc2VsZWN0b3IsIHJvb3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IGVsZW1lbnRzQnlDb25zdHJ1Y3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBmbGF0KGVsZW1lbnRzLm1hcCgoeCkgPT4gcmVkdWNlVHJlZUJ5U2VsZWN0b3IoeC50YWcsIHJvb3QpKSk7XG5cbiAgICAgIC8vIHdoZW4gaHR0cHM6Ly9naXRodWIuY29tL2F3ZWFyeS9yc3Qtc2VsZWN0b3ItcGFyc2VyL2lzc3Vlcy8xNSBpcyByZXNvbHZlZFxuICAgICAgLy8gY29uc3QgaHRtbFRhZ05hbWVzID0gZWxlbWVudHMubWFwKHggPT4geC50YWcpLmpvaW4oJywgJyk7XG4gICAgICAvLyByZXR1cm4gcmVkdWNlVHJlZUJ5U2VsZWN0b3IoaHRtbFRhZ05hbWVzLCByb290KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHJlZUZpbHRlcihyb290LCBidWlsZFByZWRpY2F0ZShzZWxlY3RvcikpO1xuICB9XG5cbiAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBzYWZlbHlHZW5lcmF0ZVRva2VucyhzZWxlY3Rvcik7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpbmRleF07XG4gICAgICAvKipcbiAgICAgICAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgdG9rZW5zIGluIGEgQ1NTIHNlbGVjdG9yOlxuICAgICAgICpcbiAgICAgICAqIDEuIFNlbGVjdG9yIHRva2Vucy4gVGhlc2UgdGFyZ2V0IG5vZGVzIGRpcmVjdGx5LCBsaWtlXG4gICAgICAgKiAgICB0eXBlIG9yIGF0dHJpYnV0ZSBzZWxlY3RvcnMuIFRoZXNlIGFyZSBlYXN5IHRvIGFwcGx5XG4gICAgICAgKiAgICBiZWNhdXNlIHdlIGNhbiB0cmF2ZXJzZSB0aGUgdHJlZSBhbmQgcmV0dXJuIG9ubHlcbiAgICAgICAqICAgIHRoZSBub2RlcyB0aGF0IG1hdGNoIHRoZSBwcmVkaWNhdGUuXG4gICAgICAgKlxuICAgICAgICogMi4gQ29tYmluYXRvciB0b2tlbnMuIFRoZXNlIHRva2VucyBjaGFpbiB0b2dldGhlclxuICAgICAgICogICAgc2VsZWN0b3Igbm9kZXMuIEZvciBleGFtcGxlID4gZm9yIGNoaWxkcmVuLCBvciArXG4gICAgICAgKiAgICBmb3IgYWRqYWNlbnQgc2libGluZ3MuIFRoZXNlIGFyZSBoYXJkZXIgdG8gbWF0Y2hcbiAgICAgICAqICAgIGFzIHdlIGhhdmUgdG8gdHJhY2sgd2hlcmUgaW4gdGhlIHRyZWUgd2UgYXJlXG4gICAgICAgKiAgICB0byBkZXRlcm1pbmUgaWYgYSBzZWxlY3RvciBub2RlIGFwcGxpZXMgb3Igbm90LlxuICAgICAgICovXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gU0VMRUNUT1IpIHtcbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0gYnVpbGRQcmVkaWNhdGVGcm9tVG9rZW4odG9rZW4sIHJvb3QpO1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQodHJlZUZpbHRlcihyb290LCBwcmVkaWNhdGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGNhbiBhc3N1bWUgdGhlcmUgYWx3YXlzIGFsbCBwcmV2aW91c2x5IG1hdGNoZWQgdG9rZW5zIHNpbmNlIHNlbGVjdG9yc1xuICAgICAgICAvLyBjYW5ub3Qgc3RhcnQgd2l0aCBjb21iaW5hdG9ycy5cbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0b2tlbjtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoZSBuZXh0IHRva2VuIGlzIGEgc2VsZWN0b3IsIHNvIG1vdmUgdGhlIGluZGV4XG4gICAgICAgIC8vIGZvcndhcmQgYW5kIGJ1aWxkIHRoZSBwcmVkaWNhdGUuXG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlRnJvbVRva2VuKHRva2Vuc1tpbmRleF0sIHJvb3QpO1xuICAgICAgICAvLyBXZSBtYXRjaCBhZ2FpbnN0IG9ubHkgdGhlIG5vZGVzIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIG1hdGNoZWQsXG4gICAgICAgIC8vIHNpbmNlIGEgY29tYmluYXRvciBpcyBtZWFudCB0byByZWZpbmUgYSBwcmV2aW91cyBzZWxlY3Rvci5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgLy8gVGhlICsgY29tYmluYXRvclxuICAgICAgICAgIGNhc2UgQURKQUNFTlRfU0lCTElORzpcbiAgICAgICAgICAgIHJlc3VsdHMgPSBtYXRjaEFkamFjZW50U2libGluZ3MocmVzdWx0cywgcHJlZGljYXRlLCByb290KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFRoZSB+IGNvbWJpbmF0b3JcbiAgICAgICAgICBjYXNlIEdFTkVSQUxfU0lCTElORzpcbiAgICAgICAgICAgIHJlc3VsdHMgPSBtYXRjaEdlbmVyYWxTaWJsaW5nKHJlc3VsdHMsIHByZWRpY2F0ZSwgcm9vdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBUaGUgPiBjb21iaW5hdG9yXG4gICAgICAgICAgY2FzZSBDSElMRDpcbiAgICAgICAgICAgIHJlc3VsdHMgPSBtYXRjaERpcmVjdENoaWxkKHJlc3VsdHMsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBUaGUgJyAnICh3aGl0ZXNwYWNlKSBjb21iaW5hdG9yXG4gICAgICAgICAgY2FzZSBERVNDRU5EQU5UOiB7XG4gICAgICAgICAgICByZXN1bHRzID0gbWF0Y2hEZXNjZW5kYW50KHJlc3VsdHMsIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb21iaW5hdG9yIHNlbGVjdG9yOiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuenltZTo6U2VsZWN0b3IgZXhwZWN0cyBhIHN0cmluZywgb2JqZWN0LCBvciBDb21wb25lbnQgQ29uc3RydWN0b3InKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZVRyZWVzQnlTZWxlY3RvcihzZWxlY3Rvciwgcm9vdHMpIHtcbiAgY29uc3QgcmVzdWx0cyA9IHJvb3RzLm1hcCgobikgPT4gcmVkdWNlVHJlZUJ5U2VsZWN0b3Ioc2VsZWN0b3IsIG4pKTtcbiAgcmV0dXJuIHVuaXF1ZShmbGF0KHJlc3VsdHMsIDEpKTtcbn1cbiJdfQ==","map":{"version":3,"sources":["D:\\React\\todomatic\\node_modules\\enzyme\\src\\selectors.js"],"names":["parser","CHILD","ADJACENT_SIBLING","GENERAL_SIBLING","DESCENDANT","SELECTOR","TYPE_SELECTOR","CLASS_SELECTOR","ID_SELECTOR","UNIVERSAL_SELECTOR","ATTRIBUTE_PRESENCE","ATTRIBUTE_VALUE","PSEUDO_CLASS","PSEUDO_ELEMENT","EXACT_ATTRIBUTE_OPERATOR","WHITELIST_ATTRIBUTE_OPERATOR","HYPHENATED_ATTRIBUTE_OPERATOR","PREFIX_ATTRIBUTE_OPERATOR","SUFFIX_ATTRIBUTE_OPERATOR","SUBSTRING_ATTRIBUTE_OPERATOR","unique","nodes","operator","value","name","token","nodeProps","descriptor","Object","nodePropValue","parameters","reduceTreeBySelector","n","rendered","firstChild","adapter","document","node","matchAttributeSelector","matchPseudoSelector","nodeMatchesToken","buildPredicate","tokens","safelyGenerateTokens","isComplexSelector","buildPredicateFromToken","isElementType","Array","selector","hasUndefinedValues","parent","parentChildren","nodeIndex","adjacentSibling","predicate","matches","youngerSiblings","childrenOfNode","elements","x","results","index","type","matchAdjacentSiblings","matchGeneralSibling","matchDirectChild","matchDescendant","reduceTreesBySelector"],"mappings":"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","sourcesContent":["import { createParser } from 'rst-selector-parser';\nimport values from 'object.values';\nimport flat from 'array.prototype.flat';\nimport is from 'object-is';\nimport has from 'has';\nimport elementsByConstructor from 'html-element-map/byConstructor';\nimport {\n  treeFilter,\n  nodeHasId,\n  findParentNode,\n  nodeMatchesObjectProps,\n  childrenOfNode,\n  hasClassName,\n} from './RSTTraversal';\nimport { nodeHasType, propsOfNode } from './Utils';\nimport getAdapter from './getAdapter';\n// our CSS selector parser instance\nconst parser = createParser();\n\n// Combinators that allow you to chance selectors\nconst CHILD = 'childCombinator';\nconst ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nconst GENERAL_SIBLING = 'generalSiblingCombinator';\nconst DESCENDANT = 'descendantCombinator';\n\n// Selectors for targeting elements\nconst SELECTOR = 'selector';\nconst TYPE_SELECTOR = 'typeSelector';\nconst CLASS_SELECTOR = 'classSelector';\nconst ID_SELECTOR = 'idSelector';\nconst UNIVERSAL_SELECTOR = 'universalSelector';\nconst ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nconst ATTRIBUTE_VALUE = 'attributeValueSelector';\n// @TODO we dont support these, throw if they are used\nconst PSEUDO_CLASS = 'pseudoClassSelector';\nconst PSEUDO_ELEMENT = 'pseudoElementSelector';\n\nconst EXACT_ATTRIBUTE_OPERATOR = '=';\nconst WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nconst HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nconst PREFIX_ATTRIBUTE_OPERATOR = '^=';\nconst SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nconst SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\nfunction unique(arr) {\n  return [...new Set(arr)];\n}\n\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\nfunction uniqueReduce(fn, nodes) {\n  return unique(nodes.reduce(fn, []));\n}\n\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error(`Failed to parse selector: ${selector}`);\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  const { operator, value, name } = token;\n  const nodeProps = propsOfNode(node);\n  const descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n  const nodePropValue = nodeProps[name];\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return has(nodeProps, token.name);\n  }\n  // Only the exact value operator (\"=\") can match non-strings\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return is(nodePropValue, value);\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(`${value}-`);\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n    default:\n      throw new Error(`Enzyme::Selector: Unknown attribute selector operator \"${operator}\"`);\n  }\n}\n\n\nfunction matchPseudoSelector(node, token, root) {\n  const { name, parameters } = token;\n  if (name === 'not') {\n    // eslint-disable-next-line no-use-before-define\n    return parameters.every((selector) => reduceTreeBySelector(selector, node).length === 0);\n  }\n  if (name === 'empty') {\n    return treeFilter(node, (n) => n !== node).length === 0;\n  }\n  if (name === 'first-child') {\n    const { rendered } = findParentNode(root, node);\n    const [firstChild] = rendered;\n    return firstChild === node;\n  }\n  if (name === 'last-child') {\n    const { rendered } = findParentNode(root, node);\n    return rendered[rendered.length - 1] === node;\n  }\n  if (name === 'focus') {\n    if (typeof document === 'undefined') {\n      throw new Error('Enzyme::Selector does not support the \":focus\" pseudo-element without a global `document`.');\n    }\n    const adapter = getAdapter();\n    /* eslint-env browser */\n    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;\n  }\n\n  throw new TypeError(`Enzyme::Selector does not support the \"${token.name}\" pseudo-element or pseudo-class selectors.`);\n}\n\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\nfunction nodeMatchesToken(node, token, root) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n  switch (token.type) {\n    /**\n     * Match every node\n     * @example '*' matches every node\n     */\n    case UNIVERSAL_SELECTOR:\n      return true;\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n    case CLASS_SELECTOR:\n      return hasClassName(node, token.name);\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n    case TYPE_SELECTOR:\n      return nodeHasType(node, token.name);\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n    case ID_SELECTOR:\n      return nodeHasId(node, token.name);\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      return matchPseudoSelector(node, token, root);\n    default:\n      throw new Error(`Unknown token type: ${token.type}`);\n  }\n}\n\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\nfunction buildPredicateFromToken(token, root) {\n  return (node) => token.body.every((bodyToken) => nodeMatchesToken(node, bodyToken, root));\n}\n\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\nfunction isComplexSelector(tokens) {\n  return tokens.some((token) => token.type !== SELECTOR);\n}\n\n\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {EnzymeSelector} selector\n */\nexport function buildPredicate(selector) {\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    }\n    // Simple selectors only have a single selector token\n    return buildPredicateFromToken(tokens[0]);\n  }\n\n  // If the selector is an element type, check if the node's type matches\n  const adapter = getAdapter();\n  const isElementType = adapter.isValidElementType\n    ? adapter.isValidElementType(selector)\n    : typeof selector === 'function';\n  if (isElementType) {\n    return (node) => adapter.matchesElementType(node, selector);\n  }\n  // If the selector is an non-empty object, treat the keys/values as props\n  if (typeof selector === 'object') {\n    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {\n      const hasUndefinedValues = values(selector).some((value) => typeof value === 'undefined');\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n      return (node) => nodeMatchesObjectProps(node, selector);\n    }\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n\n  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');\n}\n\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    // If there's no parent, there's no siblings\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const adjacentSibling = parentChildren[nodeIndex + 1];\n    // No sibling\n    if (!adjacentSibling) {\n      return matches;\n    }\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n    return matches;\n  }, []);\n}\n\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const youngerSiblings = parentChildren.slice(nodeIndex + 1);\n    return matches.concat(youngerSiblings.filter(predicate));\n  }, nodes);\n}\n\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(childrenOfNode(node).filter(predicate)),\n    nodes,\n  );\n}\n\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(treeFilter(node, predicate)),\n    flat(nodes.map(childrenOfNode)),\n  );\n}\n\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n *\n * @param {EnzymeSelector} selector\n * @param {RSTNode} root\n */\nexport function reduceTreeBySelector(selector, root) {\n  if (typeof selector !== 'string') {\n    const elements = elementsByConstructor(selector);\n    if (elements.length > 0) {\n      return flat(elements.map((x) => reduceTreeBySelector(x.tag, root)));\n\n      // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved\n      // const htmlTagNames = elements.map(x => x.tag).join(', ');\n      // return reduceTreeBySelector(htmlTagNames, root);\n    }\n  }\n\n  if (typeof selector === 'function' || typeof selector === 'object') {\n    return treeFilter(root, buildPredicate(selector));\n  }\n\n  let results = [];\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    let index = 0;\n    while (index < tokens.length) {\n      const token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can traverse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjacent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n      if (token.type === SELECTOR) {\n        const predicate = buildPredicateFromToken(token, root);\n        results = results.concat(treeFilter(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        const { type } = token;\n        // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n        index += 1;\n        const predicate = buildPredicateFromToken(tokens[index], root);\n        // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, predicate, root);\n            break;\n          // The ~ combinator\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, predicate, root);\n            break;\n          // The > combinator\n          case CHILD:\n            results = matchDirectChild(results, predicate);\n            break;\n          // The ' ' (whitespace) combinator\n          case DESCENDANT: {\n            results = matchDescendant(results, predicate);\n            break;\n          }\n          default:\n            throw new Error(`Unknown combinator selector: ${type}`);\n        }\n      }\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n  return results;\n}\n\nexport function reduceTreesBySelector(selector, roots) {\n  const results = roots.map((n) => reduceTreeBySelector(selector, n));\n  return unique(flat(results, 1));\n}\n"]},"metadata":{},"sourceType":"script"}